/*
 * filtroFIR.c
 *
 *  Created on: 26/08/2015
 *      Author: jdani
 */

#include "MEL_includes.h"
#include <stdlib.h>
#include <stdio.h>

#include <sys/mman.h>
#include "hwlib.h"
#include "socal.h"
#include "hps.h"
#include "alt_gpio.h"
#include "fixedptc.h"


float fc[] = {300,358.98,421.45,487.6,557.66,631.85,710.41,793.61,881.72,975.03,1073.84,1178.47,1289.29,1406.64,1530.9,1662.51,1801.87,1949.46,2105.75,2271.26,2446.53,2632.15,2828.71,3036.87,3257.31,3490.75,3737.96,4000}; //28 Valores

// shift the n point spectrum in into the mel frequency m point spectrum mel

void load_signal( SIGNAL * FIR_signal, char * filename)
{
	FILE * pFile;
	long lSize;
	char * buffer;
	int i;
	size_t result;

	pFile = fopen (filename,"rb");
	if(pFile==NULL)
	{
		printf("No se pudo leer el archivo.\n");
		exit (1);
	}

	//obtain file size
	fseek (pFile , 0 , SEEK_END);
	lSize = ftell (pFile);
	rewind (pFile);

	//allocate memory to contain the whole file
	buffer = (char*) malloc (sizeof(char)*lSize);

	if (buffer == NULL)
	{
		printf("Error en memoria");
		exit (2);
	}

	//copy the file into the buffer
	result = fread (buffer,1,lSize,pFile);
	if (result != lSize)
	{
		printf("Error de lectura");
		exit (3);
	}
	printf("Archivo almacenado en buffer.\n");

	FIR_signal->lenght=lSize;
	FIR_signal->signal=(int*) malloc (sizeof(int)*FIR_signal->lenght);

	for(i=0;i<lSize; i++)
	{
		FIR_signal->signal[i]=(int)buffer[i];
	}

	//terminate
	fclose(pFile);
	free(buffer);
}


void melcepstrum_conversion(float in[], int n, float mel[], int m, float fs)
{
    int i, j;

    float deltaf = fs / n;
    for (i = 0; i < m; i++)
    {
        mel[i] = 0.0;
        for (j = 0; j < n; j++)
        {
            mel[i] += in[j]*melH(j*deltaf, i+1);
        }
        mel[i] = log10(mel[i]);
    }
}

// compute the value of the mel triangle filter bank i at frequency f
double melH(int f, int i)
{
    if (f < fc[i-1] || f >= fc[i+1]) return 0;
    if (f < fc[i]) return (f-fc[i-1])/(fc[i]-fc[i-1]);
    else           return (f-fc[i+1])/(fc[i]-fc[i+1]);
}

// O(n2) dct - simple but slow (use for small vectors only)
void dct(float in[], float out[], int n)
{
    int i,j;

    double pn = PI / n;
    for (i = 0; i < n; i++)
    {
        out[i] = 0.0;
        for (j = 0; j < n; j++)
        {
            out[i] += in[j]*sin(i*pn*(j+0.5));
        }
    }
}
